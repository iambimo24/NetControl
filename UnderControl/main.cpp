// UnderControl: 用 libdatachannel + OpenCV 采集摄像头并通过 DataChannel 发送 JPEG 帧
// 构建依赖：libdatachannel, OpenCV, nlohmann_json (header-only)
// Makefile 已提供，假设系统已安装这些依赖并且 pkg-config 可找到 libdatachannel/opencv4

#include <rtc/rtc.hpp>
#include <nlohmann/json.hpp>
#include <opencv2/opencv.hpp>

#include <chrono>
#include <iostream>
#include <memory>
#include <string>
#include <thread>

using json = nlohmann::json;

int main(int argc, char** argv) {
    std::string signaling_host = "localhost";
    std::string signaling_port = "8081";
    std::string id = "undercontrol1";

    if (argc > 1) id = argv[1];
    if (argc > 2) signaling_host = argv[2];
    if (argc > 3) signaling_port = argv[3];

    std::string ws_url = "ws://" + signaling_host + ":" + signaling_port + "/ws?id=" + id + "&role=undercontrol";

    std::cout << "信令: " << ws_url << std::endl;

    // 配置 PeerConnection
    rtc::Configuration config;
    config.iceServers.push_back({"stun:stun.l.google.com:19302"});

    auto pc = std::make_shared<rtc::PeerConnection>(config);

    // 当本地生成 ICE candidate 时，发送到信令服务器
    pc->onLocalCandidate([&](const rtc::Candidate& c) {
        try {
            json msg = {
                {"type", "candidate"},
                {"from", id},
                {"payload", c.to_json()}
            };
            // 使用 WebSocket later: push to queue
            std::string s = msg.dump();
            // we'll send via ws in the outer scope
        } catch (...) {}
    });

    // 数据通道（发送 JPEG 帧）
    rtc::DataChannelInit dcInit;
    auto dc = pc->createDataChannel("frames", dcInit);

    // OpenCV capture
    cv::VideoCapture cap(0);
    if (!cap.isOpened()) {
        std::cerr << "无法打开摄像头" << std::endl;
        return 1;
    }

    // WebSocket signaling using libdatachannel's WebSocket helper
    auto ws = std::make_shared<rtc::WebSocket>(ws_url);

    // queue for outbound messages (simple, not thread-safe for production)
    std::mutex sendMu;
    std::vector<std::string> sendQueue;

    ws->onopen([&]() {
        std::cout << "信令 WebSocket 已连接" << std::endl;
    });

    ws->onmessage([&](const std::string& message) {
        try {
            auto j = json::parse(message);
            std::string t = j.value("type", "");
            if (t == "answer") {
                std::string sdp = j.value("payload", "");
                rtc::Description desc(sdp, "answer");
                pc->setRemoteDescription(desc).then([&]() {
                    std::cout << "已设置 remote description (answer)" << std::endl;
                });
            } else if (t == "candidate") {
                auto candid = j["payload"];
                // payload is the JSON generated by Candidate::to_json()
                try {
                    pc->addRemoteCandidate(rtc::Candidate::from_json(candid));
                } catch (const std::exception& e) {
                    std::cerr << "添加 candidate 失败: " << e.what() << std::endl;
                }
            } else if (t == "error") {
                std::cerr << "信令错误: " << j.dump() << std::endl;
            }
        } catch (const std::exception& e) {
            std::cerr << "解析信令消息失败: " << e.what() << std::endl;
        }
    });

    ws->onclose([&]() {
        std::cout << "信令 WebSocket 关闭" << std::endl;
    });

    // 当本地 description 准备好（offer）时，发送给信令服务器
    pc->onLocalDescription([&](rtc::Description d) {
        json msg = { {"type", d.type()}, {"from", id}, {"payload", d.sdp()} };
        std::string s = msg.dump();
        std::lock_guard<std::mutex> g(sendMu);
        sendQueue.push_back(s);
    });

    // 当 DataChannel 打开后，开始捕获和发送帧
    dc->onopen([&]() {
        std::cout << "DataChannel 已打开，开始发送帧" << std::endl;
        std::thread([&]() {
            std::vector<uchar> buf;
            cv::Mat frame;
            while (dc->isOpen()) {
                cap >> frame;
                if (frame.empty()) continue;
                // 压缩为 JPEG
                cv::imencode(".jpg", frame, buf, {cv::IMWRITE_JPEG_QUALITY, 70});
                // 如果数据较大，建议做分片；此示例直接发送完整二进制
                dc->send(buf.data(), buf.size());
                std::this_thread::sleep_for(std::chrono::milliseconds(100)); // ~10fps
            }
        }).detach();
    });

    // 在主循环中处理待发送信令
    std::thread sender([&]() {
        while (ws->isOpen() || true) {
            std::vector<std::string> toSend;
            {
                std::lock_guard<std::mutex> g(sendMu);
                toSend.swap(sendQueue);
            }
            for (auto &s : toSend) {
                if (ws->isOpen()) ws->send(s);
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
    });

    // Connect websocket (non-blocking)
    ws->open();

    // 创建 offer 并由 onLocalDescription 回调发送
    pc->createOffer().then([&](rtc::Description offer) {
        pc->setLocalDescription(offer);
    }).catchError([](std::exception const& e) {
        std::cerr << "createOffer 失败: " << e.what() << std::endl;
    });

    // 简单的事件循环，直到按 Ctrl+C
    std::cout << "运行中，按 Ctrl+C 退出" << std::endl;
    while (true) std::this_thread::sleep_for(std::chrono::seconds(1));

    return 0;
}
